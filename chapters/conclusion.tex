\section{Conclusions}

All parts of the top-k spatial join can be performed on the GPU with varying degrees of parallelism. Efficient utilization of GPGPU can be achieved by identifying the parts of an application that can be parallelized, then finding parallel solutions with respect to GPU architecture, which is significantly different from ordinary processor architecture. The best performance is achieved with special care for memory access and by dividing problems into as many independent tasks as possible that can be executed in parallel.

R-trees can be represented in device memory as a compact array of R-tree node records divided into segments. By placing node records into blocks that are aligned with the memory transactions of the GPU, the cost of random access to all records of a node should be kept as low as possible. They can be efficiently bulk loaded using a series of segmented parallel radix sorts to partition the data into tiles, then using parallel reductions to calculate node MBBs and aggregate data values.

The Block-based Algorithm can be performed entirely on the GPU with all data completely residing within GPU memory. Unindexed inputs can be sorted by score on the GPU using parallel radix sort prior to performing top-k spatial joins. A top-k spatial join can be evaluated in parallel by dividing the problem into multiple top-k spatial joins then finding the top-k elements among the results. Multiple ranked spatial joins on R-trees can be performed in parallel. Moreover, a ranked spatial join on R-trees exhibits parallelism in the form of parallel evaluation of spatial predicates for all combinations of node records. However, the cost of maintaining priority queues is expected to be comparatively high on the GPU.

While most of the methods presented are based on proven GPGPU methods that have exhibited speedups, the full solution for top-k spatial joins on GPU has not yet been verified by experimentation. There may be unknown factors affecting the performance, and a number of tweaks may be necessary to achieve competitive performance. However, crafting a parallelized version of an existing algorithm is a necessary first step in achieving top-k spatial joins on GPU.

\section{Future work}

An necessary continuation of this work is an evaluation of the methods presented by implementing them in CUDA and experimenting with various data of different distributions and sizes. A natural comparison would be between single-threaded implementations, multi-threaded implementations and GPGPU implementations. While the original Block-based algorithm has been tested and proven to be efficient, the adaptation for GPGPU may not be as efficient due to a number of unknown factors or challenges in the implementation. The only way to verify the viability of these methods is by experimentation and iterating on the solution based on performance analysis.

An interesting modification could be modifying the R-tree memory layout so that the R-tree node records are stored in breadth-first order. The reason that this is an interesting modification is because it would render the \(idx\) field of the inner node records obsolete. If an inner node record is stored at position \(i\) of a segment of an R-tree record array, then the records of the node are stored in the \(i^{th}\) block in the next segment. By removing the \(idx\) field, the required size of each record in memory is reduced, which may relax the padding requirements. By reducing the size of the R-tree in memory, less memory bandwidth would be required which would increase the performance. However, this would require a different bulk loading implementation that can produce R-trees in breadth-first order.

Another avenue of research for top-k spatial joins is using other data structures such as the family of quadtree data structures. The R-tree is considered a data-driven spatial data structure because the way it partitions the space is dependent on the data. Unlike the R-tree, the quadtree is considered a space-driven spatial data structure because it uses a fixed division of the space. Because the division of the space is not dependent on the data, quadtree bulk loading methods may be able to more efficiently partition the data. However, for data whose indexed spatial attributes cannot be represented as a single point, duplicate entries may have to be inserted into the quadtree, which introduces the problem of eliminating duplicates during spatial joins which would present some challenges, especially for parallel evaluation of top-k queries.

Another surprisingly simple way to achieve parallel top-k spatial joins might be using a parallel plane-sweep based join. While the plane sweep join algorithm cannot produce outputs in ranked order, a number of top-k joins could be performed in parallel by sorting then dividing the data into different segments and performing a top-k join on each segment. The top-k results could then be joined into a single top-k result.
