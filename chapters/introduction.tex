In many applications with spatial objects, objects have both spatial attributes and non-spatial attributes. As an example, an application such as Google Maps provides points of interest and businesses, primarily with their geographic location, but also with reviews, user ratings and various other metadata. Spatial objects are also recorded in scientific fields such as atmospheric, oceanographic and environmental sciences with measurements of several attributes such as temperature, pressure and seismic activity.

Object attributes can be used as scores to derive a ranking, which often is used to perform a top-k query when the amount of objects is too large for all objects to be relevant. A top-k query retrieves the \(k\) objects with the best ranking according to some query. A top-k join is a special case of a top-k query which is performed on the results of a join. If the inputs of the top-k join are each given a score, a top-k join can retrieve the top-k joined tuples that maximize an aggregate score, such as the average score.

A spatial join retrieves pairs of spatial objects from two different data sets that satisfy a spatial predicate, such as retrieving all intersecting pairs of objects or all pairs of objects within a certain distance from each other. As an example, given a set of all restaurants and a set of all hotels in Oslo, we would like to find pairs of restaurants and hotels that are within 1000 meters from each other for an overnight visit and dinner. The amount of restaurants and hotels within 1000 meters of each other will result in too many pairs to work with, so a reasonable solution is to limit our search to find only the most highly rated pairs. We can make this top-k query, where we would like to find the 10 pairs of restaurants and hotels with the best total rating. Highly rated locations can easily be found, but the most highly rated locations are not necessarily found in close proximity to each other. We can also find many pairs of locations that are close to each other, but we may not find the pairs with the best ratings quickly. An efficient solution must be able to use both their locations and their ratings to answer the query.

A spatial join can be an expensive operation because spatial datasets can be complex and very large. Spatial indexing data structures such as R-trees are therefore used to increase the performance of spatial queries, and can be used to perform efficient spatial joins. By adapting methods from ranked joins, it is possible to answer top-k spatial joins efficiently by only partially evaluating spatial joins, reducing the amount processing required to compute the answer.

R-trees were traditionally designed to optimize I/O performance. With hardware trends such as reduced I/O costs, increasing memory sizes, multicore processors and graphics processors becoming commodity hardware, new methods are invented to fully utilize the hardware. One way to increase performance is by exploiting parallelism, which is enabled by multicore processors, distributed computing and graphics processors. However, traditional methods often require careful redesign to exploit parallelism, or entirely new methods must be designed.

The trend of General Purpose computing on Graphics processors (GPGPU) is enabled by programmable graphics processors using APIs such as CUDA\@. GPGPU presents an opportunity to achieve massively parallel computation, but not without limitations. The architecture of GPUs and CPUs are dissimilar in ways that require special care in the design of applications to be able to fully utilize the resources of a GPU, and not all applications can truly be adapted for GPGPU.\@ The use of GPGPU in certain database operators has been studied and have in some cases been shown to have speedups compared to CPU for operations such as relational joins~\cite{he2008relational} and spatial joins~\cite{yampaka2012spatial}. We would like to find out if similar speedups can be achieved for top-k spatial joins using GPGPU.\@

Top-k queries, top-k joins and spatial joins have been extensively studied, but joins considering both spatial and score attributes at the same time have received limited attention~\cite{qi2013efficient}. Some methods have been proposed for the evaluation for top-k spatial joins, but it is believed that they can be made more efficient. One direction for research is evaluating the existing methods for parallel processing using multi-core processors or GPGPU.

This thesis is divided into a number of chapters. The second chapter covers General-purpose computing on graphics processors (GPGPU). This includes important aspects of GPU architecture that affect the design of GPGPU applications as well as the CUDA programming model. The third chapter covers spatial indexing concepts and methods, which relates to queries about the location, size and shape of objects in \(n\)-dimensional space. The R-tree is the main data structure used in this thesis, thus a number of techniques for performing spatial queries and joins using R-trees are described. The fourth chapter covers ranked query concepts and methods. Methods for top-k joins and top-k spatial joins are described. The fifth chapter covers a theoretical adaptation of top-k spatial joins on the GPU. The full design could not yet be fully evaluated, but it is described in detail. Finally, a conclusion and further work is outlined in the final chapter.

\section{Related Work}

Brinkhoff et al.~\cite{brinkhoff1993efficient} described a method to to perform spatial intersection joins by performing a concurrent descend down two R-trees. The basic principle is that if two entries of different R-trees intersect, the nodes containing each entry must also intersect. Therefore, the algorithm recursively descends down each intersecting pair of nodes, starting at the roots until it reaches the leaves.

The work of Qi et al.~\cite{qi2013efficient} forms the algorithmic basis of this work. Their contributions are three algorithms for top-k spatial joins called the Distance-First Algorithm (DFA), the Score-First Algorithm (SFA) and the Block-based Algorithm (BA). Each algorithm focuses differently on the score attributes and spatial attributes of the input objects. The DFA and BA use a ranked version of the R-tree spatial intersection join. SFA and BA borrow elements of previous implementations of top-k queries and top-k joins by accessing input elements in descending order of rank. BA is found perform best in general. The algorithms are not explicitly designed to be multithreaded, nor is the use of GPUs to implement the algorithms considered.

You et al.~\cite{you2013parallel} and Luo et al.~\cite{luo2012parallel} achieved significant speedups for parallel evaluation of multiple spatial queries on R-trees on GPUs. Their works describe two alternative solutions for memory representation of R-trees and bulk loading of R-trees on the GPU. \cite{you2013parallel} describes the linearized R-tree layout, which represents the R-tree as a single compact array of nodes that can easily be streamed between CPU and GPU, and uses an algorithm called Sort-Tile-Recursive to bulk load R-trees by using parallel sorting an reduction primitives implemented on the GPU. \cite{luo2012parallel} describes a similar layout based on two arrays, one containing the MBBs and the other containing the structure as well as data entries, which is bulk loaded using a much cheaper algorithm. The experiments performed by You et al.~suggest that their more expensive bulk loading algorithms produces R-trees with better parallel query performance. In their experiments, they perform spatial queries in parallel using basic graph traversal methods and find that their implementation of breadth-first search generally outperforms depth-first search on a GPU. They suggest a number of strategies for dealing with the limited capacity of shared memory for queues in breadth-first search.

Yampaka et al.~\cite{yampaka2012spatial} describe methods to perform spatial join operations on R-trees on a GPU. While their methods are somewhat unclear, they demonstrate a clear possibility of parallelization of the R-tree join using concurrent tree traversal described by Brinkhoff el al. Given two R-tree nodes to be joined, the GPU can efficiently assign one lightweight thread per pair of R-tree node records to parallelize the evaluation of the spatial predicate.

Bouros et al.~\cite{bouros2019spatial} review research and recent trends in the evaluation of spatial intersection joins and suggest future directions for research. Many techniques were designed for disk resident data, but the recent trend of memories becoming much larger allows more of the data to reside in memory, which calls for techniques designed for in-memory processing. Another trend is the use of distributed and parallel processing, where methods to process spatial joins using the MapReduce paradigm are reviewed. They suggest that one direction for future research should be ``scaling up'' into shared-memory multi-core systems or using GPUs instead of ``scaling out'' into distributed systems because common datasets can fit in the memory of commodity machines. They also suggest that extended join operations require research, which are spatial join operations which deal with more than spatial attributes, such as the top-k spatial join.

% TODO

%\begin{figure}[h]
%    \centering
%    \includegraphics[scale=0.5]{ntnu}
%    \caption{Norwegian Institute of Science and Technology}
%    \label{fig:ntnu}
%\end{figure}